/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=true,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.brentcroft.util.xpath;

import com.brentcroft.util.xpath.gob.Gob;
import com.brentcroft.util.xpath.gob.Selection;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static java.lang.String.format;

public class SimpleNode implements Node
{
    protected Node parent;

    protected Node[] children;

    protected int id;

    protected XParser parser;

    public SimpleNode( int i )
    {
        id = i;
    }

    public SimpleNode( XParser p, int i )
    {
        this( i );
        parser = p;
    }

    // Factory method
    public static Node jjtCreate( XParser p, int id )
    {
        return new SimpleNode( p, id );
    }

    public void jjtOpen()
    {
    }

    public void jjtClose()
    {
    }

    public void jjtSetParent( Node n )
    {
        parent = n;
    }

    public void jjtSetChildren( Node[] n )
    {
        children = n;
    }

    public Node jjtGetParent()
    {
        return parent;
    }

    public void jjtAddChild( Node n, int i )
    {
        if ( id == XParserTreeConstants.JJTNCNAME
             && ( ( SimpleNode ) n ).id == XParserTreeConstants.JJTQNAME )
        {
            m_value = ( ( SimpleNode ) n ).m_value;
            if ( m_value.indexOf( ':' ) >= 0 )
            {
                throw new PostParseException(
                        "Parse Error: NCName can not contain ':'!" );
            }
            return;
        }
        // Don't expose the functionQName as a child of a QName!
        else if ( id == XParserTreeConstants.JJTQNAME
                  && ( ( SimpleNode ) n ).id == XParserTreeConstants.JJTFUNCTIONQNAME )
        {
            m_value = ( ( SimpleNode ) n ).m_value;
            return;
        }
        if ( children == null )
        {
            children = new Node[ i + 1 ];
        }
        else if ( i >= children.length )
        {
            Node c[] = new Node[ i + 1 ];
            System.arraycopy( children, 0, c, 0, children.length );
            children = c;
        }
        children[ i ] = n;
    }

    public Node jjtGetChild( int i )
    {
        return children[ i ];
    }

    public int jjtGetNumChildren()
    {
        return ( children == null ) ? 0 : children.length;
    }

    @Override
    public int getId()
    {
        return id;
    }

    /**
     * Accept the visitor. *
     */
    public Selection accept( XParserVisitor visitor, Gob gob, Selection axis )
    {
        return visitor.visit( this, gob, axis );
    }


    /*
     * You can override these two methods in subclasses of SimpleNode to
     * customize the way the node appears when the tree is dumped. If your
     * output uses more than one line you should override toString(String),
     * otherwise overriding toString() is probably all you need to do.
     */

    public String toString()
    {
        return format( "%s : [%s] %s", XParserTreeConstants.jjtNodeName[ id ], m_value == null ? "" : m_value, getPath() );
    }

    public String toString( String prefix )
    {
        return prefix + toString();
    }

    /*
     * Override this method if you want to customize how the node dumps out its
     * children.
     */

    public void dump( String prefix )
    {
        dump( prefix, System.out );
    }

    public void dump( String prefix, java.io.PrintStream ps )
    {
        ps.print( toString( prefix ) );
        printValue( ps );
        ps.println();
        if ( children != null )
        {
            for ( int i = 0; i < children.length; ++ i )
            {
                SimpleNode n = ( SimpleNode ) children[ i ];
                if ( n != null )
                {
                    n.dump( prefix + "   ", ps );
                }
            }
        }
    }


    public String getPath()
    {
        StringBuilder b = new StringBuilder();
        concatTokens( b );
        return b.toString();
    }

    public void concatTokens( StringBuilder b )
    {
        switch ( getId() )
        {
            case XParserTreeConstants.JJTPREDICATE:

                b.append( "[ " );
                getChildTokens( b );
                b.append( " ]" );

                break;

            case XParserTreeConstants.JJTFUNCTIONCALL:

                b.append( "( " );
                getChildTokens( b );
                b.append( " )" );

                break;


            case XParserTreeConstants.JJTEQUALITYEXPR:

                getChildTokens( b, size() == 0 );

                break;

            case XParserTreeConstants.JJTABBREVFORWARDSTEP:

                if ( m_value != null )
                {
                    b.append( m_value );

                    getChildTokens( b );

                    break;
                }


            default:
                if ( size() > 0 )
                {
                    getChildTokens( b );
                }
                else
                {
                    Optional
                            .ofNullable( getValue() )
                            .ifPresent( value -> b.append( value ) );
                }
        }
    }

    private void getChildTokens( StringBuilder b )
    {
        getChildTokens( b, false );
    }

    private void getChildTokens( StringBuilder b, boolean noValuePrefix )
    {
        if ( size() > 0 )
        {
            boolean isFirst = true;
            for ( Node c : getChildren() )
            {
                SimpleNode child = ( SimpleNode ) c;

                if ( noValuePrefix || isFirst )
                {
                    child.concatTokens( b );

                    isFirst = false;
                }
                else
                {
                    Optional
                            .ofNullable( getValue() )
                            .ifPresent( value -> b.append( value ) );

                    child.concatTokens( b );
                }
            }
        }
    }


    // Manually inserted code begins here

    protected String m_value;

    public void processToken( Token t )
    {
        m_value = t.image;
    }

    public void processValue( String val )
    {
        m_value = val;
    }

    public void printValue( java.io.PrintStream ps )
    {
        if ( null != m_value )
        {
            ps.print( " " + m_value );
        }
    }

    public String getValue()
    {
        return m_value;
    }

    public void setValue( String m_value )
    {
        this.m_value = m_value;
    }

    private Object _userValue;

    protected Object getUserValue()
    {
        return _userValue;
    }

    protected void setUserValue( Object userValue )
    {
        _userValue = userValue;
    }

    public List< ? extends Node > getChildren()
    {
        if ( children == null )
        {
            return null;
        }
        else if ( children.length < 1 )
        {
            return Collections.EMPTY_LIST;
        }
        else
        {
            return Arrays.asList( children );
        }
    }

    public SimpleNode getChild( int i )
    {
        return ( SimpleNode ) jjtGetChild( i );
    }

    public int size()
    {
        return jjtGetNumChildren();
    }

}
